
package threadPools.threadPoolLibrary;

import threadPools.threadPoolLibrary.DataInAndOut;
import threadPools.threadPoolLibrary.RandomMaker;

import threadPools.util.Debug;

/**
 * 
 */

/**
 * @author      Devon McBride <dmcbrid1@binghamton.edu> 
 *                            <devonmcb@yahoo.com>
 * @since       1.6.0_16
 * 
 * ...for Assignment 2, cs342, Program Design Patterns
 * 
 * creates runnables to generate random numbers.  
 * When the runnables create random numbers, 
 * they store them into the singleton object 
 * named DataInAndOut. 
 * 
 */
public class RandomRunner implements Runnable{

	private int             MM = 0; // thread ID
	private long          seed = 0;
	private int     knownPrime = 0;
	private int howManyRandoms = 0;  // how many Randoms to make

	/**
	 * the constructor
	 * @param MM used as the thread's ID here
	 * @param seed to seed the Random object
	 * @param knownPrime a prime from the knownPrimes array
	 * @param howManyRandoms the number of randoms to make
	 **/
	public RandomRunner(long seed, int MM, int knownPrime, int howManyRandoms)
	{
		this.MM             = MM;
		this.seed           = seed;
		this.knownPrime     = knownPrime;
		this.howManyRandoms = howManyRandoms;
	}	

	/**
	 * does the job of making random numbers and storing them into 
	 * the DataInAndOut singleton data structure. 
	 **/
	public void run() {
		try 
		{			
		
		if (Debug.DEBUG_VALUE > 2) say("-----------in a Generator Runnable---------------");
	   	if (Debug.DEBUG_VALUE > 2) say("Thread " + MM + ", seed " + seed);
		if (Debug.DEBUG_VALUE > 2) say("known prime: "+ knownPrime + " will be put into results.");
	    if (Debug.DEBUG_VALUE > 2) say("This thread will find " + howManyRandoms + " random numbers.");
			
		if (Debug.DEBUG_VALUE > 3) say("got singleton instance of RandomRunner");

		// As instructed, store a known prime, 
		// in case no prime is generated randomly.
		DataInAndOut.storeResult(knownPrime);		
				
		RandomMaker r1 = new RandomMaker(seed);
		int randy = r1.getRandy();
	    if (Debug.DEBUG_VALUE > 3) say("The 1th random generated by thread "+MM+" is: "+randy);
		DataInAndOut.storeResult(randy);

		// allowing system to provide seed because mine gives repetitive
		RandomMaker r2 = new RandomMaker();
		for(int i=2; i<howManyRandoms; i++)
		{
			// use no arg. constructor to rely on system time for seed.
			randy = r2.getRandy();
			if (Debug.DEBUG_VALUE > 3) say("The "+i+"th random generated by thread "+MM+" is: "+randy);
			DataInAndOut.storeResult(randy);
			//sleep a bit because Random class uses system time as seed.
			try { Thread.sleep(250); } catch (InterruptedException x) {  }
		}
		if (Debug.DEBUG_VALUE > 3) say(toString());
		} 
		catch(Exception e) 
		{
	        System.out.println("run() terminating in RandomRunner with exception:");
		     System.err.println(e);
	        System.exit(1);
	    }
	}
		
	// I got this idea from: 
	// http://www.javapractices.com/topic/TopicAction.do?Id=62
	/**
	 * This makes it so the programmer doesn't have to bloat 
	 * code with the awkward & messy-looking "System.out.println"
	 * 
	 * @param a String to be printed to std out. 
	 */
	private static void say(String message){
	    System.out.println(message);
	}
		
    /**
     *  toString method returns a string containing all the data 
     *  members of this class with clear descriptions.
     */
	public String toString() {
		String objectState = null; //return all data members
		objectState  = "----------------------------------\n";
		objectState += "class RandomRunner's data members: \n";
		objectState += "            MM = " + MM + "\n";
		objectState += "          seed = " + seed + "\n";
		objectState += "    knownPrime = " + knownPrime + "\n";
		objectState += "howManyRandoms = " + howManyRandoms + "\n";
		objectState += "------------Thank you------------";
		return objectState;
	}	
}
